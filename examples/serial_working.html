<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TryValkey</title>
    <script src="../build/libv86.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ansi_up@5.0.0/ansi_up.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@4.16.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="../src/browser/serial.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@4.16.0/css/xterm.css" />
    <style>
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 10px;
        }

        #terminal-container {
            width: 100%;
            height: 300px;
            font-family: monospace;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }

        #loadingContainer {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h3>Terminal Output</h3>
        <div id="terminal-container"></div>
    </div>

    <!-- Progress bar and message display -->
    <div id="loadingContainer">
        <p id="progressText" style="font-family: 'Open Sans', sans-serif; font-size: 18px;">Preparing to load...</p>
        <progress id="progressBar" value="0" max="100" style="width: 80%; height: 30px;"></progress>
    </div>

    <script>
        "use strict";
        const FILE_URL = "../images/valkey-serial.bin.gz";  // Path to the .gz file
        const CACHE_KEY = "valkey_binary_cache";
        const LAST_MODIFIED_KEY = "valkey_last_modified";
        let emulator;

        // Function to handle IndexedDB for binary storage
        async function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("binaryCacheDB", 1);
                
                request.onerror = () => reject("Error opening IndexedDB");
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    db.createObjectStore("cache", { keyPath: "key" });
                };
            });
        }

        // Get the cached binary from IndexedDB
        async function getCachedBinary(db) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(["cache"], "readonly");
                const objectStore = transaction.objectStore("cache");
                const request = objectStore.get(CACHE_KEY);
                
                request.onerror = () => reject("Error retrieving cached binary");
                request.onsuccess = () => resolve(request.result ? request.result.data : null);
            });
        }

        // Save the binary to IndexedDB
        async function saveBinaryToCache(db, data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(["cache"], "readwrite");
                const objectStore = transaction.objectStore("cache");
                const request = objectStore.put({ key: CACHE_KEY, data: data });
                
                request.onerror = () => reject("Error saving binary to cache");
                request.onsuccess = () => resolve();
            });
        }

        // Check with the server if the binary is updated (using Last-Modified header)
        async function checkIfUpdated() {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open("HEAD", FILE_URL, true);
                
                xhr.onload = () => {
                    const serverLastModified = xhr.getResponseHeader("Last-Modified");
                    const cachedLastModified = localStorage.getItem(LAST_MODIFIED_KEY);

                    if (!serverLastModified || serverLastModified !== cachedLastModified) {
                        // New version detected
                        localStorage.setItem(LAST_MODIFIED_KEY, serverLastModified);
                        resolve(true);  // Need to download
                    } else {
                        resolve(false);  // No changes, use cached
                    }
                };
                
                xhr.onerror = () => reject("Error checking file version");
                xhr.send();
            });
        }

        // Download and decompress the binary if needed
        function downloadAndDecompressBinary(callback) {
            let xhr = new XMLHttpRequest();
            xhr.open("GET", FILE_URL, true);
            xhr.responseType = "arraybuffer";  // Download the file as binary

            xhr.onprogress = function(event) {
                const progressText = document.getElementById("progressText");
                const progressBar = document.getElementById("progressBar");
                if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    progressBar.value = percentComplete;  // Update the progress bar value
                }
            };

            xhr.onload = function() {
                if (xhr.status === 200) {
                    document.getElementById("progressText").innerText = "Decompressing image...";
                    const decompressedData = pako.ungzip(new Uint8Array(xhr.response));
                    callback(decompressedData);
                }
            };

            xhr.onerror = function() {
                document.getElementById("progressText").innerText = "Download failed!";
            };

            xhr.send();
        }

        async function loadEmulator(decompressedData) {
            var progressText = document.getElementById("progressText");

            // Convert decompressed data to Blob for v86
            let blob = new Blob([decompressedData], { type: "application/octet-stream" });
            let imgUrl = URL.createObjectURL(blob);

            progressText.innerText = "Starting emulator...";

            emulator = new V86({
                wasm_path: "../build/v86.wasm",
                memory_size: 512 * 1024 * 1024,
                vga_memory_size: 8 * 1024 * 1024,
                bios: { url: "../bios/seabios.bin" },
                vga_bios: { url: "../bios/vgabios.bin" },
                filesystem: {
                    baseurl: "../images/alpine-rootfs-flat-new",
                    basefs: "../images/alpine-fs-new.json",
                },
                autostart: true,
                bzimage_initrd_from_filesystem: true,
                cmdline: "rw root=host9p rootfstype=9p rootflags=trans=virtio,cache=loose modules=virtio_pci tsc=reliable",
                initial_state: { url: imgUrl },
            });

            const serialAdapter = new SerialAdapterXtermJS(document.getElementById('terminal-container'), emulator.bus)
            serialAdapter.show()

            progressText.style.display = "none";  // Hide the text after emulator starts
            document.getElementById("loadingContainer").style.display = "none";  // Hide the loading container
        }

        window.onload = async function() {
            const db = await openIndexedDB();
            try {
                const needsDownload = await checkIfUpdated();

                if (needsDownload) {
                    // Download, decompress, cache, and then load to emulator
                    downloadAndDecompressBinary(async (decompressedData) => {
                        await saveBinaryToCache(db, decompressedData);
                        loadEmulator(decompressedData);
                    });
                } else {
                    // Load from cache
                    const cachedBinary = await getCachedBinary(db);
                    if (cachedBinary) {
                        loadEmulator(cachedBinary);
                    } else {
                        // Cache is empty, fallback to downloading
                        downloadAndDecompressBinary(async (decompressedData) => {
                            await saveBinaryToCache(db, decompressedData);
                            loadEmulator(decompressedData);
                        });
                    }
                }
            } catch (error) {
                console.error("Error loading binary: ", error);
                document.getElementById("progressText").innerText = "Failed to load binary.";
            }
        };


    </script>
</body>

</html>
